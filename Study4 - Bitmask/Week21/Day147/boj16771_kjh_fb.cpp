// 비트마스킹을 이용해 완전탐색을 하는 모범답안
// 분석하면서 되게 신기했음

#include <stdio.h>

// 경우의 수가 존재하는지를 나타내는 vis[1201]. 인덱스는 첫째 헛간이 가지는 우유탱크의 양의 경우의 수 의미
// 물통 크기들을 담는 c
bool vis[1201], c[20];

// k는 요일. 월(1)~금(5)
// m1, m2는 각 헛간의 우유탱크
// h1, h2는 각 헛간의 물통 보유현황
void f(int k, int m1, int m2, int h1, int h2) {
	// 금요일이라면 m1의 경우의수가 존재한다고 표시하고 끝냄
	if (k == 5) {
		// m1은 첫째 헛간의 우유탱크
		vis[m1] = true;
		return;
	}
	// 홀수 요일에는
	if (k % 2) {
		for (int i = 0; i < 20; i++)
		     // 만약 첫째 헛간의 i번째 물통이 존재한다면
		     if (h1&(1 << i))
			// 다음 요일
			// 첫째 헛간에서 i번째 물통크기만큼 뺌
			// 둘째 헛간에서 i번째 물통크기만큼 더함 (즉 첫째헛간->둘째헛간으로 i번째 물통을 나른 것)
			// 첫째 헛간의 i번째 물통이 이제 없다고 알림 
			// 둘째 헛간의 i번째 물통이 이제 생겼다고 알림
			f(k + 1, m1 - c[i], m2 + c[i], h1 ^ (1 << i), h2 ^ (1 << i));
	}
	// 짝수 요일에는
	else {
		for (int i = 0; i < 20; i++)
		     // 만약 둘째 헛간의 i번째 물통이 존재한다면
		     if (h2&(1 << i))
			// 다음 요일
			// 둘째 헛간에서 i번째 물통크기만큼 뺌
			// 첫째 헛간에서 i번째 물통크기만큼 더함 (즉 둘째헛간->첫째헛간으로 i번째 물통을 나른 것)
			// 둘째 헛간의 i번째 물통이 이제 없다고 알림 
			// 첫째 헛간의 i번째 물통이 이제 생겼다고 알림
			f(k + 1, m1 + c[i], m2 - c[i], h1 ^ (1 << i), h2 ^ (1 << i));
	}
}

int main() {
	// 0~19의 물통 입력받음
	for (int i = 0; i < 20; i++)
		scanf("%d", &c[i]);
	// 1 							=> 월요일
	// 1000, 1000			=> 각 헛간의 우유탱크
	// 1023 					=> 00000000001111111111 => 첫째 헛간에 0~9의 물통이 있다
	// 1048575 ^ 1023	=> 11111111110000000000 => 둘째 헛간에 10~19의 물통이 있다
	f(1, 1000, 1000, 1023, 1048575 ^ 1023);
	int res = 0;
	// 가능한 경우의 수 0~1200를 순회하며 만약 그 경우의 수가 존재했다면 카운트
	for (int i = 0; i <= 1200; i++) if (vis[i]) res++;
	// 경우의 수 카운트 출력
	printf("%d\n", res);
	return 0;
}